# 数据类型

## 布尔型
- 数字无法代替布尔值进行逻辑判断
    - 两者是完全不同的类型。
    
|**类型**|**描述**|
|--|--|
|`bool`|`true` 为真值， `false` 为假值|

## 数字型

### 整型
|**序号**|**描述**|
|--|--|
|`uint8`|无符号8位整型|
|`uint16`|无符号 16 位整型|
|`uint32`|无符号32位整型|
|`uint64`|无符号 64 位整型|
|`int8`|有符号 8 位整型|
|`int16`|有符号 16 位整型|
|`int32`|有符号 32 位整型|
|`int64`|有符号64位整型|
|`uint`|无符号整型至少32位|
|`int`|整型至少32位|
|`uintptr`|等价于无符号64位整型，但是专用于存放指针运算，用于存放死的指针地址。|

### 浮点型
|**类型**|**描述**|
|--|--|
|`float32`|IEEE-754 32位浮点数|
|`float64`|IEEE-754 64位浮点数|

### 复数型
|**类型**|**描述**|
|--|--|
|`complex128`|64位实数和虚数|
|`complex64`|32位实数和虚数|

## 字符串型
- 兼容 `UTF-8`

|**类型**|**描述**|
|--|--|
|`byte`|等价 `uint8`，可以表达 ANSCII 字符|
|`rune`|等价 `int32`，可以表达 Unicode 字符|
|`string`|字符串即字节序列，可以转换为`[]byte` 类型，即**字节切片**|

## 派生型
|**类型**|**例子**|
|--|--|
|数组|`[5]int`,长度为5的整型数组|
|切片|`[]float64`,64位浮点数切片|
|映射表|`map[string]int`,键为字符串类型，值为整型的映射表|
|结构体|`type Gopher struct{}`,Gopher结构体|
|指针|`*int`,一个整型指针。|
|函数|`type f func()`,一个没有参数，没有返回值的函数类型|
|接口|`type Gopher interface{}`,Gopher接口|
|通道|`chan int` ,整型通道|

## 零值（zero value）
- 不仅是字面上的数字0，而应是类型的空值/默认值

|**类型**|**零值**|
|--|--|
|数字类型|`0`|
|布尔类型|`false`|
|字符串类型|`""`|
|数组|固定长度的对应类型的零值集合|
|结构体|内部字段都是零值的结构体|
|切片，映射表，函数，接口，通道，指针|`nil`|

- 特殊的零值——`nil`
    - `nil` 类似于其它语言中的 `none` 或者 `null`，但并不等同。
    - `nil` 仅仅只是一些引用类型的零值，并且不属于任何类型
    - 从源代码中的 nil 可以看出它仅仅只是一个变量。
        ```go
        var nil Type
        ```
    - `nil == nil` 无法通过编译


---


# 变量

## 变量声明
- 声明时类型后置，使用 `var` 关键字
- 格式：
    ```go
    var 变量名 变量类型
    ```

- 声明多个同类型变量时可以只写一次类型
    ```go
    var numA, numB int
    ```

- 声明多个不同类型变量时，可以用 `()` 包裹，可以多块分布
    ```go
    var (
    name    string
    age     int
    address string
    )

    var (
    school string
    class int
    )
    ```

- 如果声明而不赋值，则默认使用零值

## 赋值
- 使用运算符 `=`
```go
var name string
var age int
name, age = "jack", 1
```

- 函数内的所有变量都必须使用，否则报错
- 但是包级变量无限制

## 声明时赋值
- 提供语法糖：短变量初始化
    - 可以省略掉 `var` 关键字和后置类型
    - 具体是什么类型交给编译器自行推断
```go
name := "jack" // 字符串类型的变量。
name, age := "jack", 1  // 也可以批量操作

```

- 但是后续赋值时，类型必须一致
- 而且短变量初始化不能使用 `nil`，因为不属于任何类型，无法推断

- 不能对已存在变量使用
    - 使用 `var 变量名 类型` 的就不能再使用 `:=` 做推断
    - 已经做推断的就视为存在类型，不应再次推断
```go
// 错误示例
var a int
a := 1

// 错误示例
a := 1
a := 2
```

- 但可以赋值旧变量的同时声明一个新的变量
```go
a := 1
a, b := 2, 2
```

## 匿名
- 使用 `_` 做弃元
    - 未使用的变量是无法通过编译的
    - 当你不需要某一个变量时，就可以使用下划线 `_` 代替。
```go
// 有函数声明为
Open(name string) (*File, error)

// 使用_作为返回的 *File，作为弃元抛弃
file, _ := os.Open("readme.txt")
```

## 交换
- 直接使用赋值运算符交换
```go
num1, num2 := 25, 36
num1, num2 = num2, num1
```

- 先计算再赋值

## 比较
- 前提：类型必须相同
    - go 语言中不存在隐式类型转换
    - 必须使用强制类型转换
```go
func main() {
  var a uint64
  var b int64
  fmt.Println(int64(a) == b)
}
```

- 在 go 1.21 后，可以使用 `min`/`max` 函数比较最值
```go
minVal := min(1, 2, -1, 1.2)
maxVal := max(100, 22, -1, 1.12)
```

- 参数支持所有的可比较类型
    - 布尔
    - 数字
    - 字符串
    - 指针
    - 通道 （仅支持判断是否相等）
    - 数组：要求元素是可比较类型
        - 切片不可比较
        - 仅支持判断是否相等
        - 仅支持相同长度的数组间的比较，因为数组长度也是类型的一部分，而不同类型不可比较
    - 结构体：要求字段类型都是可比较类型（仅支持判断是否相等）
- 另外也有标准库 `cmp`
    - 不过仅支持有序类型的参数
    - 在 go 中内置的有序类型只有数字和字符串。

## 代码块
- 在函数内部，可以通过花括号建立一个代码块
- 代码块彼此之间的变量作用域是相互独立的。
- 块与块之间的变量相互独立，不受干扰，无法访问，但是会受到父块中的影响。


---


# 常量
- 常量的值无法在运行时改变，一旦赋值过后就无法修改，其值只能来源于：
    - 字面量
    - 其他常量标识符
    - 常量表达式
    - 结果是常量的类型转换
    - iota

- 常量只能是基本数据类型，不能是
    - 除基本类型以外的其它类型，如结构体，接口，切片，数组等
    - 函数的返回值
- 常量的值无法被修改，否则无法通过编译

## 初始化
- 使用 `const` 关键字。
- 声明时赋值，类型可省略
    - 只声明不赋值会报错无法通过编译
```go
const name string = "Jack" // 字面量
const msg = "hello world" // 字面量
const num = 1 // 字面量
const numExpression = (1+2+3) / 2 % 100 + num // 常量表达式
```

- 批量声明可以用 `()` 括起来提升可读性
    - 可以多个 `()` 实现分组
    - 同分组内，已经赋值常量后面的值默认复制前面的值，除非指定新值。

- 常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。
    - 常量表达式中，函数必须是内置函数
    - 否则编译不过
    ```go
    package main

    import "unsafe"
    const (
        a = "abc"
        b = len(a)
        c = unsafe.Sizeof(a)
    )

    func main(){
        println(a, b, c)
    }
    ```

> [!note]
> - unsafe.Sizeof(a)输出的结果是16 。
> - 字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。

## iota
- `iota` 是一个内置的常量标识符
- 通常用于表示一个常量声明中的无类型整数序数
- 一般都是在括号中使用。

- iota是递增的
    - 第一个常量使用iota值的表达式，根据序号值的变化会自动的赋值给后续的常量
    - 直到用新的const重置
    - 这个序号其实就是代码的相对行号，是相对于当前分组的起始行号
    - 而不同的const分组则相互不会影响
```go
const (
  Num  = iota<<2*3 + 1 // 1 第0行
  Num2 = iota<<2*3 + 1 // 13 第1行
  _ // 25,因为复制了值为iota<<2*3 + 1，此时在第2行
  Num3 //37,因为复制了值为iota<<2*3 + 1，此时在第3行
  Num4 = iota // 4 第4行
  _ // 5,因为复制了值为iota，此时在第5行所以为5
  Num5 // 6,因为复制了值为iota，此时在第6行
)
```

## 枚举
- 没有为枚举单独设计一个数据类型
- 通过「自定义类型 + const + iota」来实现枚举
    ```go
    type Season uint8

    const (
    Spring Season = iota // 0
    Summer  // 1
    Autumn  // 2
    Winter  // 3
    )
    ```

    - 实际就是数字，也不支持直接转换为字符串，但是可以通过自定义方法返回其字符串形式
        - 实现 `Stringer` 接口
    ```go
    func (s Season) String() string {
        switch s {
        case Spring:
            return "spring"
        case Summer:
            return "summer"
        case Autumn:
            return "autumn"
        case Winter:
            return "winter"
        }
        return ""
    }
    ```

- 但是有缺点
    - 类型不安全
    - 繁琐
    - 表达能力弱

# 函数

## 定义声明
- 使用 `func` 关键字定义
```go
// 函数名: Pos
// 参数: 
//  - 无输入参数
// 返回值:
//  - float类型的 x,y
func Pos() (x, y float64) {
    ...
}
```

## 形参的两种传递

### 值传递
- 值传递是指在调用函数时将实际参数复制一份传递到函数中
    - 这样在函数中如果对参数进行修改，将不会影响到实际参数。
- 默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。

### 引用传递
- Go 语言的取地址符是 `&变量`，放到一个变量前使用就会返回相应变量的内存地址。
    - 取值符是 `*地址`，通过对指针类型限定确定取值
- 引用传递是指在调用函数时将实际参数的地址传递到函数中
    - 那么在函数中对参数所进行的修改，将影响到实际参数。
- 对变量 `var a int = 100`
    - 有取址符 `&a` 的值为 `a` 的地址
    - 有值 `*&a = a`

```go
package main


import "fmt"


func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int= 200


   fmt.Printf("交换前，a 的值 : %d\n", a )
   fmt.Printf("交换前，b 的值 : %d\n", b )


   /* 调用 swap() 函数
   * &a 指向 a 指针，a 变量的地址
   * &b 指向 b 指针，b 变量的地址
   */
   swap(&a, &b)


   fmt.Printf("交换后，a 的值 : %d\n", a )
   fmt.Printf("交换后，b 的值 : %d\n", b )
}

// 无返回值
// 输入参数：int指针 x,y
func swap(x *int, y *int) {
   var temp int
   temp = *x    // 保存 指针x 对应地址上的值 *x
   *x = *y      // 将 指针y 值 *y 赋给 指针x 的值 *x
   *y = temp    // 将 temp 值赋给 指针y 的值*y
}
```

