## 1. C#类型系统概述
### 1.1 概述
- C# 是一种强类型语言。
- 每个变量和常量都有一个类型，每个求值的表达式也是如此。
- 每个方法声明都为每个输入参数和返回值指定名称、类型和种类（值、引用或输出）。
- .NET 类库定义了内置数值类型和表示各种构造的复杂类型。
    - 其中包括文件系统、网络连接、对象的集合和数组以及日期。
    - 典型的 C# 程序使用类库中的类型，以及对程序问题域的专属概念进行建模的用户定义类型。

- 类型中可存储的信息包括以下项：
    - 类型变量所需的存储空间。
    - 可以表示的最大值和最小值。
    - 包含的成员（方法、字段、事件等）。
    - 继承自的基类型。
    - 它实现的接口。
    - 允许执行的运算种类。

- 编译器使用类型信息来确保在代码中执行的所有操作都是类型安全的。
    - 如果声明 int 类型的变量，那么编译器允许在加法和减法运算中使用此变量
    - 如果尝试对 bool 类型的变量执行这些相同操作，则编译器将生成错误
    - 编译器将类型信息作为元数据嵌入可执行文件中。
    - 公共语言运行时 (CLR) 在运行时使用元数据，以在分配和回收内存时进一步保证类型安全性。

    >[!note|label:CLR的组成]
    > CLR主要由CLS和CTS两部分组成
    > - CLS(公共语言规范)
    >     - 一个最低标准集合，所有面向.NET Framework的编译器都必须支持
    > - CTS(通用类型系统)
    >     - 一套预定义数据类型，所有面向.NET Framework的语言都可以基于此编译
    >     - 比如C#中的`int`和VB中的`integer`在编译后都经CTS转换为`System.Int32`

### 1.2 变量声明中的类型指定
- 当在程序中声明变量或常量时指定其类型
- 使用 var 关键字让编译器推断类型
    - C# 3.0 引入的**类型推断**
- 方法声明指定方法参数的类型和返回值。
- 声明变量后，不能使用新类型重新声明该变量，并且不能分配与其声明的类型不兼容的值。
    - 例如，不能声明 `int` 后再向它分配 `true` 的布尔值。
    - 不过，可以将值转换成其他类型。
        - 例如，在将值分配给新变量或作为方法自变量传递时，编译器会自动执行不会导致数据丢失的类型转换。
        - 如果类型转换可能会导致数据丢失，必须在源代码中进行显式转换。
    > [!note|label:参考笔记]
    > * [变量与常量](/ProjectDocs/cs/Back-end-Development/Csharp/2-3-Variable-Constant.md)
    > * [类型的转换](/ProjectDocs/cs/Back-end-Development/Csharp/2-4-Type-Convert.md)

### 1.3 内置类型
- C# 提供了一组标准的内置类型。
    - 这些类型表示整数、浮点值、布尔表达式、文本字符、十进制值和其他数据类型。
    - 还有内置的 string 和 object 类型。
- 这些类型可供在任何 C# 程序中使用。
    - 有关内置类型的完整列表，查看官方文档[内置类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/built-in-types)

### 1.4 自定义类型
- 可以使用 `struct`、`class`、`interface`、`enum` 和 `record` 构造来创建自己的自定义类型。
- .NET 类库本身是一组自定义类型，以供你在自己的应用程序中使用。
    - 查看官方文档[.NET 类库概述](https://learn.microsoft.com/zh-cn/dotnet/standard/class-library-overview)
- 默认情况下，类库中最常用的类型在任何 C# 程序中均可用。
- 其他类型只有在显式添加对定义这些类型的程序集的项目引用时才可用。
- 编译器引用程序集之后，你可以声明在源代码的此程序集中声明的类型的变量（和常量）。 

### 1.5 通用类型系统 CTS

#### 1. CTS的两个原则
1. 支持继承原则
    - 类型可以派生自其他类型（称为**基类型**）。
        - 派生类型继承（有一些限制）基类型的方法、属性和其他成员。
        - 基类型可以继而从某种其他类型派生，在这种情况下，派生类型继承其继承层次结构中的两种基类型的成员。
            - 即: **基类的基类 -> 基类 -> 基类的子类**
    - 所有类型（包括 `System.Int32` (C# keyword: `int`) 等内置数值类型）最终都派生自单个基类型，即 `System.Object` (C# keyword: `object`)。
    - 这样的统一类型层次结构称为**通用类型系统 (CTS)**。
    - 官方文档:[继承 - 派生用于创建更具体的行为的类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/object-oriented/inheritance)
2. CTS 中的每种类型被定义为**值类型**或**引用类型**
    - 这些类型包括 .NET 类库中的所有自定义类型以及你自己的用户定义类型。
    - 使用 `struct` 关键字定义的类型是值类型
        - **所有内置数值类型**都是 `structs`。
    - 使用 `class` 或 `record` 关键字定义的类型是引用类型。
    - 引用类型和值类型遵循不同的编译时规则和运行时行为。

#### 2. CTS中值类型和引用类型的关系
- 如果用树形图描述继承将如下:
    - 使用 `[]` 标记引用类型
    - 使用 `【】` 标记值类型
```
System 命名空间
 |
 · —— * [System.Object 类]
      |
      · —— · [所有的基类(Base Class)/库类(Library Class)/接口(interface)]
      |    |
      |    * —— [System.String 类]
      |    * —— [System.Array 类]
      |    * —— [用户自定义的类和接口]
      |    |
      |    · —— [其他继承类/接口]
      | 
      · —— * [System.ValueType 类]
           |
           · —— * [System.Enum 类]
           |    |
           |    · —— 【所有的枚举类】
           · —— · 【所有的结构体，包括内置数值类型(即基元类型)】
                |
                * —— 【System.Int32】
                * —— 【System.Boolean】
                * —— 【用户自定义的结构体】
                |
                · —— 【其他结构体】

```
#### 3. 类、结构、记录之间的区别
- 类和结构是 .NET 通用类型系统的两种**基本构造**。
    - C# 9 添加记录(`record`)，**记录是一种类**。
    - 每种本质上都是一种数据结构，其中封装了同属一个逻辑单元的一组数据和行为。
    - 数据和行为是类、结构或记录的成员。
    - 这些行为包括方法、属性和事件等。
- 类、结构或记录声明类似于一张蓝图，用于在运行时创建实例或对象。
    - 如果定义名为 Person 的类、结构或记录，则 Person 是类型的名称。
    - 如果声明和初始化 Person 类型的变量 p，那么 p 就是所谓的 Person 对象或实例。
    - 可以创建同一 Person 类型的多个实例，每个实例都可以有不同的属性和字段值。
- **类是引用类型**。
    - 创建类型的对象后，向其分配对象的变量仅保留对相应内存的引用。
    - 将对象引用分配给新变量后，新变量会引用原始对象。
    - 通过一个变量所做的更改将反映在另一个变量中，因为它们引用相同的数据。
- **结构是值类型**。
    - 创建结构时，向其分配结构的变量保留结构的实际数据。
    - 将结构分配给新变量时，会复制结构。
    - 因此，新变量和原始变量包含相同数据的副本（共两个）。
    - 对一个副本所做的更改不会影响另一个副本。
- **记录类型**可以是引用类型 (`record class`) 或值类型 (`record struct`)。
- 用法和选择
    - 类用于对**更复杂的行为**建模。
        - 建立后可更改
            - 类通常存储计划在创建类对象后进行修改的数据。
    - 结构最适用于**小型数据结构**。
        - 建立后不可更改
            - 结构通常存储不打算在创建结构后修改的数据。
    - 记录类型是**具有附加编译器合成成员**的数据结构。
        - 建立后不可更改
            - 记录通常存储不打算在创建对象后修改的数据。
        - 可以基于`class`和`struct`建立

### 1.6 值类型
- 值类型派生自`System.ValueType`（派生自 `System.Object`）。
    - 派生自 `System.ValueType` 的类型在 CLR 中具有特殊行为。
    - 结构的内存在声明变量的任何上下文中进行内联分配。
    - 对于值类型变量，没有单独的堆分配或垃圾回收开销。
- 值类型变量直接包含其值。
- 可以声明属于值类型的 record struct 类型，并包括记录的合成成员。

- 值类型分为两类：`struct`和`enum`。
    - 内置的数值类型是结构，它们具有可访问的字段和方法
    - 但可将这些基元类型类型视为简单的非聚合类型，为其声明并赋值

- 值类型已密封。
    - 不能从任何值类型（例如 `System.Int32`）派生类型。
    - 不能将结构定义为从任何用户定义的类或结构继承，因为结构只能从 `System.ValueType` 继承。
    - 但是，一个结构可以实现一个或多个接口。
        - 可将结构类型强制转换为其实现的任何接口类型。
        - 这将导致“装箱”操作，以将结构包装在托管堆上的引用类型对象内。
        - 当你将值类型传递给使用 System.Object 或任何接口类型作为输入参数的方法时，就会发生装箱操作。
        > [!note|label:参考笔记]
        > * [类型的转换](/ProjectDocs/cs/Back-end-Development/Csharp/2-4-Type-Convert.md)

### 1.7 引用类型
- 使用`class`、`record`、`delegate`、数组或`interface`定义的类型称为**引用类型**
- 在声明引用类型变量时，它将包含默认值 `null`，直到你将其分配给该类型的实例，或者使用 `new` 运算符创建一个。 
- 无法使用 `new` 运算符直接实例化接口
    - 必须创建一个继承并实现接口的类，然后用该类的实例以使用接口
- 创建对象时，会在托管堆上分配内存。
    - 变量只保留对对象位置的引用。
    - 对于托管堆上的类型，在分配内存和回收内存时都会产生开销。
        - “垃圾回收”是 CLR 的自动内存管理功能，用于执行回收。
        - 但是，垃圾回收已是高度优化，并且在大多数情况下，不会产生性能问题。
        - 参考官方文档[CLR的自动内存管理](https://learn.microsoft.com/zh-cn/dotnet/standard/automatic-memory-management)

- 所有数组都是引用类型，即使元素是值类型，也不例外
    - 数组隐式派生自 `System.Array` 类
    - 可以使用 C# 提供的简化语法声明和使用数组
- 引用类型完全支持继承。
    - 创建类时，可以从其他任何**未定义为密封的**接口或类继承
    - 其他类可以从你的类继承并替代虚拟(`virtual`)方法。

### 1.8 文本值类型
在 C# 中，文本值从编译器接收类型。
- 可以通过在数字末尾追加一个字母来指定数字文本应采用的类型。
    - 例如，若要指定应按 float 来处理值 4.56，则在该数字后追加一个“f”或“F”，即 4.56f。
    - 参考笔记[变量与常量](/ProjectDocs/cs/Back-end-Development/Csharp/2-3-Variable-Constant.md)中`3.1 直接常量`部分。
- 如果没有追加字母，那么编译器就会推断文本值的类型。 

- 由于文本已类型化，且所有类型最终都是从 `System.Object` 派生，因此可以编写和编译如下所示的代码：
    ```cs
    string s = "The answer is " + 5.ToString(); //使用Int.ToString()方法，重写自Object类
    Console.WriteLine(s);// Outputs: "The answer is 5"

    Type type = 12345.GetType(); //实际进行装箱，然后使用Object.GetType()方法
    Console.WriteLine(type);// Outputs: "System.Int32"
    ```

### 1.9 泛型类型
- 可使用一个或多个类型参数声明的类型，用作实际类型（具体类型）的占位符.
- 客户端代码在创建类型实例时提供具体类型。
- 这种类型称为泛型类型。
- 例如，.NET 类型 `System.Collections.Generic.List<T>` 具有一个类型参数`T`
    - 当创建类型的实例时，指定列表将包含的对象的类型，例如 `string`：
    ```cs
    List<string> stringList = new List<string>();
    stringList.Add("String example");

    ```
- 通过使用类型参数，可以用同一个类中的泛型参数以保存任意类型的元素，且无需将每个元素转换为对象
- 泛型集合类称为强类型集合
    - 因为编译器知道集合元素的具体类型，并能在编译时引发错误
    - 例如当尝试向上面示例中的 stringList 对象添加整数时。 
    ```cs
    List<string> stringList = new List<string>();
    stringList.Add(4);  //
    ```


## 命名空间

## 类

## 记录

## 接口

## 泛型

## 匿名类型
