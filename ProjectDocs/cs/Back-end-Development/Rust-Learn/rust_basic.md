## RUST 语句/函数/数据类型/语法记录

其中数据类型/语法记录包括

- 数据类型
    - 标准类
    - String 字符串
    - enum 枚举
    - Result 枚举
    - Ordering 枚举
- 语法
    - :: 关联函数
    - & 引用
    - {占位符} -> Print运用

----


### 为函数导入新的库
`use 源库::目标库`  
默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为`预导入（preclude）`内容。你可以在标准库文档中查看预导入的所有内容。  
如果你需要的类型不在预导入内容中，就必须使用 use 语句显式地将其引入作用域。



### 声明新函数
`fn main(参数) {函数体内容}`  



### 打印字符
`println!("字符串内容");`  
将字符串内容打印在窗口中。



### 创建变量
`let a=1`   
新建 `不可变`a变量 并且绑定在值1上  
`let mut b=1`  
新建 `可变`b变量 并且绑定在值1上

### 数值运算
所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会向零舍入到最接近的整数。
[Rust支持的运算符Link](https://kaisery.github.io/trpl-zh-cn/appendix-02-operators.html)



### 调用某库中某函数
`库名::函数名`  
引入该库中某函数，示例如下：  
`std::io::stdin`  
表示引入std库中io库的stdin函数



### match表达式
一个 `match` 表达式由 `分支（arms）` 构成。一个分支包含一个`模式（pattern）`和表达式开头的值与分支模式相匹配时应该执行的代码。
Rust 获取提供给 match 的值并挨个检查每个分支的模式。



---


## 数据类型 data type
***注意：区分大小写！***


[***对于两种基本数据类型的解释Link**](https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html)




### 标量Scalar
含有四种标准：**整形、浮点型、布尔类型和字符类型**。




#### 整形
占据32bit的无符号整数(u开头)
*有符号整数类型以i开头

长度| 有符号| 无符号
-------|-------|------
8-bit| i8	| u8
16-bit | i16 | u16
32-bit | i32 | u32
64-bit | i64 | u64
128-bit | i128 | u128
arch | isize | usize

每一个变体都可以是有符号或无符号的，并有一个明确的大小。
有符号 和 无符号 代表数字能否为负值，换句话说，这个数字是否有可能是负数（有符号数），或者永远为正而不需要符号（无符号数）。
这有点像在纸上书写数字：
当需要考虑符号的时候，数字以加号或减号作为前缀；然而，可以安全地假设为正数时，加号前缀通常省略。

有符号数以补码形式（two’s complement representation） 存储。所以 i8 可以储存从 -2^7^到 2^7^-1 在内的数字，也就是从 -128 到 127。
无符号的变体可以储存从 0 到 2^n-1^ 的数字，所以 u8 可以储存从 0 到 2^8^-1 的数字，也就是从 0 到 255。

另外，isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的。

**具体表现方法如下：**
- Decimal (十进制)	 98_222  --> 使用_来方便读数 实际值等同于98222
- Hex (十六进制)	 0xff
- Octal (八进制)	 0o77
- Binary (二进制)	 0b1111_0000
- Byte (单字节字符)(仅限于u8)	 b'A'
*数字类型默认是 i32。isize 或 usize 主要作为某些集合的索引。*
***实际操作中注意 整型溢出IntegerOverflow 的可能存在。***
*当在 debug 模式编译时，Rust 检查这类问题并使程序 panic*



#### 浮点型
带小数点的数字。
浮点数类型是`f32`和`f64`。默认类型为`f64`，因为在现代CPU中，他与`f32`速度几乎一样，但是精度更高。
所有浮点型都是有符号的。

    浮点数采用 IEEE-754 标准表示。
    f32 是单精度浮点数，即float，4字节有效7位；
    f64 是双精度浮点数，Double，8字节有效16位。



#### 布尔型
包含两种值`true`和`false`。布尔类型标识为`bool`。



#### 字符类型
原生字符类型：`char`。
    例句：
    fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
               }
单引号声明 `char` 字面量，使用双引号声明 `字符串` 字面量。
    Rust 的 char 类型的大小为四个字节 (four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。
    在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。
    Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。
    不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 char 并不符合。



#### 复合类型
可以把多个值组合成一个类型，包含两种组合类型`元组tuple`和`数组array`。


##### 元组类型
元组是一个将多个其他类型的值组合进一个复合类型的主要方式。
元组长度固定：一旦声明，其长度不会增大或缩小。
声明方法：(类型,类型,类型，···)

    示例：
    let tup: (i32, f64, u8) = (500, 6.4, 1);

表示tup绑定在了一个元组构成为`(i32,f64,u8)`格式的`(500,6.4,1)`。

但是此时tup是一个单独的复合元素，获取单独值时要使用`模式匹配PatternMatching`来`解构destructure`元组值。

    示例：
    let tup = (500,6.4,1);
    let (x,y,z) = tup;

首先创建了个元组并且绑定在`tup`上，接着使用let和一个模式`(x,y,z)`将tup分成三个变量，该步骤即为`解构destructure`
另有一种访问方法，使用点号`.`后跟值的索引方法。`tup.1`即为`f64`格式值`6.4`
*与大多数编程语言相同，第一个索引值为0*

*不带任何值的元组称为`单元unit`,值及其对应类型均写作`()`，表示控制或者空的返回类型。*
*如果表达式不返回任何其他值，会隐式返回单元值*


##### 数组类型
数组中的每个元素类型必须相同，数组长度同样固定。
声明方法：[值，值，···]

    示例：
    let a = [1,2,3,4,5];
通常是在`栈stack`上分配空间(而非`堆heap`)，或是确保有固定数量元素时使用数组，但是并不如`vector`类型灵活。
`vector`类型是标准库提供的一个**允许**增长和缩短长度的类似数组的集合类型。
**当不确定应该使用array还是vector时，通常使用vector。**

也有另外的声明方法：[类型;个数]，也可以以用[值;重复个数]来创造每位都相同的数组

    let b = [i32;5]=[1,2,3,4,5];
    let c = [3;5]; ---> c=[3,3,3,3,3];
    
数组是在栈stack上分配的一直固定大小的单个内存块，可以使用索引来访问数组元素，示例：
    
    first = b[0]; 此时first即为1

访问数组结尾之后的元素时，程序在索引操作中使用一个无效的值时导致**运行时**错误。程序带着错误信息退出，并且没有执行位于其后面的其他任何语句。
当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 panic。这种检查必须在运行时进行，因为编译器不可能知道用户在以后运行代码时将输入什么值。



### String 类型
String 是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块。




### enum 类型
枚举类型 通常用`enum 枚举名 {枚举成员1,2,.....}`  
    默认成员2的值为1的值+1




### Result 类型
Result 是一种枚举类型，枚举成员为：`ok` , `Err` ；

    Ok 表示操作成功，内部包含成功后产生值
    Err 操作失败，包含失败的前因后果

___有`expect`方法：___  
返回 Err，则可能是来源于底层操作系统错误的结果。如果 Result 实例的值是 Ok，`.expect` 会获取 Ok 中的值并原样返回。




### Ordering 类型
Ordering 也是一个枚举，不过它的成员是 `Less、Greater 和 Equal`。
这是比较两个值时可能出现的三种结果。也就是`<、>、和=`




----




## 语法





### :: 语法
`::`是表明前后关联的一个`关联函数`，针对**类型**实现的。  

        'string::new()'表明new是String类型的关联函数
        在这个例子中是 String，而不是 String 的某个特定实例。

___一些语言中把它称为 静态方法（static method）。___




### & 语法
`&`表示这个参数是一个 引用（reference）。  
它允许多处代码访问同一处数据，而无需在内存中多次拷贝。  
引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用。




### {占位符} 语法
当打印变量的值时，变量名可以写进大括号中。  
当打印表达式的执行结果时，格式化字符串（format string）中大括号中留空，格式化字符串后跟逗号分隔的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。
