## 6.3 抽象类
> [!note|label:理解]
> 里氏替换原则 (继承后的重写)：  
> 父类出现地方可以被子类替换掉，要保护替换前的原有的工作，
> 在替换后依然保持不变子类在重写父类方法时，尽量选择扩展重写。  
> 
> 抽象方法和虚方法区别：  
> 从定义来说：  
>   抽象方法：只有声明【定义】，没有实现的方法 就是抽象方法；  
>   虚方法：用vritual关键修饰的已经实现的方法。  
> 语法说：  
>   抽象方法：实现类必须实现【重写】；  
>   虚方法：可以重写也可以不重写



---



### 6.3.1 抽象类的特性
- `C#` 中的抽象类同样是一种类，可以包含多个成员，但是具有以下特性：
    - 不能实例化，即不能通过 `new` 方法创建实例；
    - 可以包含抽象方法、抽象访问器；
    - 可以有非抽象方法；
    - 不能用 `sealed` 修饰，也即不能密封；
    - 被抽象类继承为派生抽象类；
    - 所派生的非抽象类必须实现基类抽象方法、抽象访问器的具体化。
- 重点内容：
    - 正确定义构造函数；
    - 保证抽象类功能的正确性和拓展性。
- 具体实现原则：
    - 不在抽象类内部定义公共的构造函数 / 受保护的内部构造函数：
        - 具有 `public` 和 `protected internal` 可见性的构造函数用于能实例化的类型；
        - 任何情况下抽象类均不应该实例化。
    - 在内部定义一个受保护构造函数 / 内部构造函数：
        - 便于创建派生类实例时执行基类的初始化；
        - 内部构造函数可以防止抽象类被用作其他程序集中类型的基类。



---



### 6.3.2 抽象方法
- 在方法中使用 `abstract` 修饰符以指示不包含实现，这样的方法称为**抽象方法**：
    - 使用 `abstract` 关键字声明；
    - 是隐式的虚方法；
    - 只允许抽象类中使用抽象方法声明；
        - 非抽象类中不能使用 `abstract` 修饰方法。
    - 一个类中可以包括一个或多个抽象方法；
    - 抽象方法声明不提供具体实现，则没有方法体；
        - 以分号结尾，签名后没有花括号；
        - 结构 `abstract [其他标识符] 返回类型 函数名(传入)`
    - 利用非抽象类重写方法成员实现；
        - 实现抽象类用 `:` ；
        - 实现抽象方法用 `override` 关键字。
    - 抽象方法不能用 `static` 和 `virual` 修饰符；
    - 抽象方法被实现后不能更改修饰符。



---



### 6.3.3 抽象属性
- 除了在声明和调用语法上不同以外,抽象属性的行为与抽象方法类似。
- 另外,抽象属性具有以下特性:
    - 在静态属性上使用 `abstract` 修饰符是错误的。
    - 在派生类中,通过使用 `override` 修饰符的属性声明可以重写抽象的继承属性；
    - 抽象属性声明不提供属性访问器的实现；
        - 只声明该类支持的属性；
        - 将访问器的实现留给其派生类。
        - 即 `[修饰符] abstract 返回类型 属性名 { [get;] [set;] }`
