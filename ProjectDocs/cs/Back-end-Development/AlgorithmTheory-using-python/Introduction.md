## 算法导论初步
使用 python 实现各类基础数据结构与算法。



---



## 1. 基本概念

> 主要使用《图解算法 使用 python 第二版》

### 1.1 算法的定义
- 在有限步骤内解决数学问题的程序
- 为了解决某项工作或某个问题所需要的**有限数量**的**机械性或重复性**指令与计算步骤

### 1.2 算法的条件
- **特性**
    算法的特性 | 内容与说明
    ----------|----------
    输入 | 0个或多个输入数据，这些输入必须有清楚的描述或定义
    输出 | 至少会有一个输出结果，不能没有输出结果
    明确性 | 每一条指令或每一个步骤必须是简洁明确的
    有限性 | 在有限步骤后一定会结束，不会产生无限循环
    有效性 | 步骤清楚且可行，只要时间允许，用户就可以用纸笔计算而求出答案
- **描述**
    - 高级语言 / 伪语言
    - 流程图
    - 图形演示（数组图、树形图、矩阵图）

### 1.3 时间复杂度
1. **定义**  
    在一个完全理想状态下的计算机中，我们用 $T(n)$ 来表示程序执行所要花费的时间，其中 $n$ 代表数据输入量。
    - 分析时间复杂度时，往往用函数来表示它的成长率（Rate of Growth）
    - 时间复杂度是一种渐进表示法（Asymptotic Notation）
    - 程序的最坏运行时间（Worse Case Executing Time）或最大运行时间是时间复杂度的衡量标准，一般以 Big-Oh 表示。

2. **理解**
    - 当某算法的运行时间 $T(n)$ 的时间复杂度为 $O(f(n))$ （读作 Big-Oh of f(n) 或 order is f(n)）
        - $O(f(n))$ 可视为某算法在计算机中所需运行时间不会超过某一常数倍的 $f(n)$ 
        - 存在常数 $c$ 和 $n_0$ ，使得对 $n \ge n_0$ ，$T(n) \le cf(n)$
        - 其中 $f(n)$ 又称为运行时间的成长率
    - 估计出来的复杂度是算法真正所需运行时间的上限

3. Big-Oh
- 常见的 Big-Oh

Big-Oh | 特色与说明
-------|-----------
$O(1)$ | 常数时间，表示算法运行时间是一个常数倍
$O(log_2n)$ | 次线性时间
$O(n)$ | 线性时间，表示执行时间会随着数据集合的大小而线性增长
$O(nlog_2n)$ | 线性乘对数时间，介于线性和二次方增长的中间模式
$O(n^2)$ | 平方时间
$O(n^3)$ | 立方时间
$O(2^n)$ | 指数时间

- 优劣性比较  
    $n \ge 16$ 时，时间复杂度的优劣比较关系如下：
    $$
        O(1) \lt O(log_2n) \lt O(n) \lt O(nlog_2n) \lt O(n^2) \lt O(n^3) \lt O(2^n)
    $$

## 2. 经典算法思想

### 2.1 分治法
将复杂大问题依照相同概念分割

### 2.2 递归法
- 函数/子程序不只能被其他函数调用/引用，可以自己调用自己，即 “递归” 。
- 至少需要两个条件：可反复执行的递归过程、跳出执行过程的出口
- 尾递归：函数最后一条语句为递归调用。
- 系统中实现使用堆栈数据结构

### 2.3 贪心法
- 从某起点开始，每一个解决问题步骤均使用贪心原则（采取当前最优选择），不断改进解答，逐步逼近目标，直到无法前进停止。
- 通常求出局部最优解/满足约束条件解。

### 2.4 动态规划法
- 类似分治法
- 但是会将已解决的问题结果储存方便调用

### 2.5 迭代法
- 使用重复结构（循环）重复执行一段代码

### 2.6 枚举法
- 列举全部可能逐一求解

### 2.7 回溯法
- 枚举法的一种
- 发现不正确数值时会回溯到上层
- 避免无效搜索
