# 数据库完整性

## 0-完整性约束概述

### 分类
- 依据对象的级别，完整性约束可以分为：
    - 列级约束：针对列的类型、取值范围、精度、排序规则等制定的约束条件。
    - 元组级约束：元组中的字段组和字段间联系的约束。
    - 表级约束：若干元组间、关系中以及关系之间联系的约束

#### 列级约束：
- 针对列的类型、取值范围、精度、排序规则等制定的约束条件。
- 对**数据类型**的约束
    - 例如，`Sno` 为 `char(9)` 数据类型
- 对**空值**的约束
    - 例如，`Sname` 不能取 `null` 值
- 对**数据格式**的约束
    - 例如，`Sno` 的值只能为数字字符
- 对**取值范围**或**取值集合**的约束
    - 例如，`Ssex` 的值只能为“男”或“女”
- 其他约束
    - 例如，`Ccredit` 可以有小数，但小数部分的值只能取0.5。

#### 元组级约束:
- 对一个元组的的字段组和字段之间应该满足的条件所做的限定\
- 即规定了属性之间的值或结构的相互制约关联。
- 例如:
    - 如果一条记录需要记录复核人和复核日期，那么这两个字段要么全部为空，要么全不为空。
    - 符合上述要求的记录，在语义上才是正确的。

#### 表级约束
- **实体完整性**约束
    - 例如，Sno是Student的主码，因此，整张表内，不允许有Sno的值有重复。
- **参照完整性**约束
    - 例如，Sno是SC的外码，因此， SC表内，不允许有Sno的值不在Student的Sno列中的情况出现。	
- **函数依赖**约束
    - 例如，如果Student表中保存有学生的身份证号码（Sid），则字段Ssex的值应该与身份号中的信息相一致。
    

### 控制机制
#### 功能
- **定义完整性**
    - 提供定义完整性约束条件的机制。
- **检查完整性**
    - 检查用户发出的操作请求，看其是否违背了完整性约束条件。
- **控制完整性**
    - 监视数据操作的整个过程
    - 如果发现有违背了完整性约束条件的情况，则采取一定的动作来保证数据的完整性。
- 该模型与一般的司法模式类似：
    - 立法机构立法
    - 检察机构检查
    - 法院依法评判后做出相应的处理。

#### 执行
- 立即执行约束
    - 有关数据操作语句执行完后，立即进行完整性检查为立即执行约束。
- 延迟执行约束
    - 在整个事务执行结束后，再进行完整性检查为延迟执行约束。

### 数据的完整性和安全性的区别
- **数据的完整性**
    - **作用：**防止数据库中存在不符合语义（也就是不正确）的数据。
    - **防范对象：**不合语义的、不正确的数据。
- **数据的安全性**
    - **作用：**防止发生恶意破坏和非法存取数据库的行为。
    - **防范对象：**非法用户和非法操作。

## 1-实体完整性

### 定义
- 关系模型的实体完整性定义
    - 用 `PRIMARY KEY` 短语定义
- 单属性构成的主码的两种定义方法 
    - 定义为列级约束条件
        - 例如，`Sno char(9) PRIMARY KEY`
    - 定义为表级约束条件
        - 例如，`PRIMARY KEY (Sno)`
- 多个属性构成的主码的定义方法
    - 定义为表级约束条件 
        - 例如，`PRIMARY KEY (Sno, Cno)`

- 示例
    ```sql
    -- 在列级定义主码
    CREATE TABLE Student (
        Sno CHAR(9) PRIMARY KEY, -- 列级
        Sname CHAR(20) NOT NULL, 
        Ssex CHAR(2),
        Sage SMALLINT,
        Sdept CHAR(20)
    )
    
    -- 在表级定义主码
    CREATE TABLE Student(
        Sno CHAR(9), 
        Sname CHAR(20) NOT NULL,
        Ssex CHAR(2),
        Sage SMALLINT,
        Sdept CHAR(20),
        PRIMARY KEY (Sno) -- 表级
    ) 
    
    -- 将SC表中的Sno, Cno属性组定义为主码。
    /* 多个属性时，只能在表级定义主码 */ 
    CREATE TABLE SC(
        Sno CHAR(9) NOT NULL, 
        Cno CHAR(4) NOT NULL, 
        Grade SMALLINT,
        PRIMARY KEY (Sno,Cno)
    ) 
    ```

### 检查和违约处理
- 插入数据或对主码列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：
    - 主码值必须唯一。
    - 主码的各个属性不能有NULL值。
- 违约处理	
    - 主码值如果不唯一，或主码的各个属性只要有一个有NULL值，就拒绝插入或修改。

- 常用的检查记录中主码值是否唯一的方法有两种
    - **全表扫描：**
        - 全表扫描是数据库服务器用来搜寻表的每一条记录的过程，直到所有符合给定条件的记录返回为止。
        - 可以全表扫描主码值，并将其与待修改记录的主码值比较，确定其唯一性。
    - **查找索引：**
        - 先在主码列（组）上建立索引
        - 然后通过扫描索引，检查在索引内是否已存在该主码值。 
- 在数据库中，只有在检查没有建立索引的表的主码值的唯一性时，才进行全表扫描。

## 2-参照完整性

### 定义
- 关系模型的参照完整性定义
    - 使用FOREIGN KEY短语定义外码，并用REFERENCES短语指明该外码参照主键表的主码。
    - 例如：
        - 关系SC中一个元组表示一个学生选修的某门课程的成绩
        - （Sno, Cno）是主码。
        - Sno，Cno分别参照引用Student表的主码Sno和Course表的主码Cno，其参照完整性核心代码如下：
            ```sql
            FOREIGN KEY (Sno) REFERENCES Student (Sno) 
            FOREIGN KEY (Cno) REFERENCES Course (Cno)
            ```
- 例子：
    ```sql
    CREATE TABLE SC(
        Sno CHAR(9) NOT NULL, 
        Cno CHAR(4) NOT NULL, 
        Grade SMALLINT,
        PRIMARY KEY (Sno, Cno), 
        /*在表级定义实体完整性*/
        FOREIGN KEY (Sno) REFERENCES Student (Sno), 
        /*在表级定义参照完整性*/
        FOREIGN KEY (Cno) REFERENCES Course (Cno)
    )
    ```

### 检查和违约处理
- 可能破坏参照完整性的情况及违约处理
    - SQL Server 2000中不支持设置为空值功能

| 被参照的外键表 | 参照表（持有外键表） | 违约处理 |
| ------------- | ------------------ | ------- |
| 可能破坏 | 插入元组/数据 *(发起)* | **拒绝** |
| 可能破坏 | 修改外码列的值 *(发起)* | **拒绝** |
| 删除元组 *(发起)* | 可能破坏 | **拒绝**/**级连删除**/**设置为空值** |
| 修改主码值 *(发起)* | 可能破坏 | **拒绝**/**级连删除**/**设置为空值** |

1. **拒绝(NO ACTION)执行**
    - 不允许该操作执行。
    - 这是默认的策略。
2. **级联(CASCADE)操作**
    - **级联修改**(`UPDATE`)：当修改主码时，同时修改对应的外码的值。
    - **级联删除**(`DELETE`)：当删除被参照表中的某条记录时，同时删除参照表中、引用了被参照表中待删除元组主码值的所有记录。
3. **设置为空值（SET-NULL）**
    - 当删除或修改被参照表的某个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设为空值。
    - SQL Server 2000中不支持该功能

- 例
    ```sql
    CREATE TABLE SC(
        Sno CHAR(9) NOT NULL,
        Cno CHAR(4) NOT NULL,
        Grade SMALLINT,
        PRIMARY KEY(Sno,Cno), 
        -- 设置外键
        FOREIGN KEY (Sno) REFERENCES Student (Sno) 
            ON DELETE CASCADE 	/*级联删除SC表中相应的元组*/
            ON UPDATE CASCADE, 	/*级联更新SC表中相应的元组*/
        FOREIGN KEY (Cno) REFERENCES Course (Cno) 	 
            /*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/
            ON DELETE NO ACTION 
            /*当更新course表中的cno时，级联更新SC表中相应的元组*/	
            ON UPDATE CASCADE 
    )
    ```

## 3-用户定义的完整性
- 针对某一具体应用的数据必须满足的语义要求

### 属性上约束

#### 定义
- 通过CREATE TABLE或ALTER TABLE语句定义，主要包括如下几种：
    - 列值非空（`NOT NULL`）
    - 列值唯一（`UNIQUE`）
    - 列值检查（`CHECK`）：检查列值是否满足一个布尔表达式

#### 检查和违约处理
- 插入元组或修改属性的值时，RDBMS检查属性上的约束条件是否被满足
    - 如果不满足，则操作被拒绝执行。

### 元组上约束

#### 定义
- 和属性上的约束条件的定义一样
    - 通过CREATE TABLE或ALTER TABLE语句定义可以用CHECK短语定义元组上的约束条件
    - 即元组级的限制。
- 同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件 。

- 例子：
    ```sql
    -- 当学生的性别是男时，其名字不能以Ms.打头。
    CREATE TABLE Student(
        Sno CHAR(9), 
        Sname CHAR(8) NOT NULL,
        Ssex CHAR(2),
        Sage SMALLINT,
        Sdept CHAR(20),
        PRIMARY KEY (Sno),
        CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%')
        /*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/
    )
    /* 注意：
    性别是女性的元组都能通过该项检查，因为Ssex=‘女’成立；
    当性别是男性时，要通过检查则名字一定不能以Ms.打头。
    */
    ```

#### 检查和违约处理
- 插入元组或修改属性的值时，RDBMS检查元组上的约束条件是否被满足
    - 如果不满足，则操作被拒绝执行。


